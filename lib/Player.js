'use strict';

const Observable = require('./Observable');
const arrayBufferToAudioBuffer = require('./utils/arrayBufferToAudioBuffer');
const toString = Object.prototype.toString;

class Player {
  constructor() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;

    this._queue = [];
    this._currentSource = null;
    this._currentBuffer = null;
    this._context = new AudioContext();

    Observable(this);
  }

  _log(type, message) {
    if (type && !message) {
      message = type;
      type = 'log';
    }

    setTimeout(() => {
      this.emit(Player.EventTypes.LOG, message);
    }, 0);

    if (this._debug) {
      console[type](message);
    }
  }

  emptyQueue() {
    return new Promise((resolve, reject) => {
      this._queue = [];
      resolve();
    });
  }

  enqueue(item) {
    return new Promise((resolve, reject) => {
      if (!item) {
        const error = new Error('argument cannot be empty.');
        this._log(error);
        return reject(error);
      }

      const stringType = toString.call(item);

      const proceed = (audioBuffer) => {
        this._queue.push(audioBuffer);
        this._log('Enqueue audio');
        this.emit(Player.EventTypes.ENQUEUE);
        return resolve(audioBuffer);
      };

      if (stringType === '[object DataView]' || stringType === '[object Uint8Array]') {
        arrayBufferToAudioBuffer(item.buffer, this._context)
        .then(proceed);
      } else if (stringType === '[object AudioBuffer]') {
        proceed(item);
      } else {
        const error = new Error('Invalid type.');
        this.emit('error', error);
        return reject(error);
      }
    });
  }

  deque() {
    return new Promise((resolve, reject) => {
      const item = this._queue.shift();

      if (item) {
        this._log('Deque audio');
        this.emit(Player.EventTypes.DEQUE);
        return resolve(item);
      }

      return reject();
    });
  }

  play() {
    return new Promise((resolve, reject) => {
      if (this._context.state === 'suspended') {
        this._context.resume();

        this._log('Play audio');
        this.emit(Player.EventTypes.PLAY);
      } else {
        return this.deque()
        .then(audioBuffer => {
          this.playAudioBuffer(audioBuffer)

          this._log('Play audio');
          this.emit(Player.EventTypes.PLAY);
        });
      }
    });
  }

  stop() {
    return new Promise((resolve, reject) => {
        if (this._currentSource) {
          this._currentSource.onended = function() {};
          this._currentSource.stop();
        }

        this._log('Stop audio');
        this.emit(Player.EventTypes.STOP);
    });
  }

  pause() {
    return new Promise((resolve, reject) => {
        if (this._context.state === 'running') {
          this._context.suspend();
        }

        this._log('Pause audio');
        this.emit(Player.EventTypes.PAUSE);
    });
  }

  replay() {
    return new Promise((resolve, reject) => {
        if (this._currentBuffer) {
          this._log('Replay audio');
          this.emit(Player.EventTypes.REPLAY);

          if (this._context.state === 'suspended') {
            this._context.resume();
          }

          this._currentSource.stop();
          this._currentSource.onended = function() {};

          return this.playAudioBuffer(this._currentBuffer);
        } else {
          const error = new Error('No audio source loaded.');
          this.emit('error', error)
          reject();
        }
    });
  }

  playBlob(blob) {
    return new Promise((resolve, reject) => {
      if (!blob) {
        reject();
      }

      const objectUrl = URL.createObjectURL(blob);
      const audio = new Audio();
      audio.src = objectUrl;

      audio.addEventListener('ended', () => {
        this._log('Audio ended');
        this.emit(Player.EventTypes.ENDED);
      });

      audio.onload = (event) => {
        URL.revokeObjectUrl(objectUrl);
      };

      this._log('Audio play started.');
      audio.play();

      resolve();
    });
  }

  playAudioBuffer(buffer) {
    return new Promise((resolve, reject) => {
      const source = this._context.createBufferSource();
      source.buffer = buffer;
      source.connect(this._context.destination);
      source.start(0);
      this._currentBuffer = buffer;
      this._currentSource = source;

      source.onended = (event) => {
        this._log('Audio ended');
        this.emit(Player.EventTypes.ENDED);
      };

      source.onerror = (error) => {
        this.emit('error', error);
      };

      resolve();
    });
  }

  static get EventTypes() {
    return {
      LOG: 'log',
      ERROR: 'error',
      PLAY: 'play',
      REPLAY: 'replay',
      PAUSE: 'pause',
      STOP: 'pause',
      ENQUEUE: 'enqueue',
      DEQUE: 'deque'
    };
  }
}

module.exports = Player;
